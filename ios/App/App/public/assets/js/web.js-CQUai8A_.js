import{W as t,a1 as e}from"../index-C69Cv9fm.js";import{E as i}from"./chunk-FepbYYb0.js";import"./chunk-DE8J_P3a.js";import"./chunk-CHPtWMTz.js";import"./chunk-DN5ISW2H.js";import"./chunk-CbEMFF6w.js";import"./chunk-hQfd_hHm.js";import"./chunk-BpSVmO2m.js";import"./chunk-DgElOEdu.js";import"./chunk-DcTAIqBw.js";import"./chunk-D_Hxdxtf.js";import"./chunk--pMnkzaH.js";import"./chunk-C0eak1NN.js";import"./chunk-BxvRdxTs.js";import"./chunk-DyZQNKrs.js";import"./chunk-D_Qk7JHd.js";import"./chunk-CKgI9q5n.js";import"./chunk-D3Z6_DOi.js";import"./chunk-YjRoWQ3-.js";import"./chunk-LoZVIojA.js";import"./chunk-CD10_Lnj.js";import"./chunk-Bc1XvzR8.js";import"./chunk-D5WpN7K-.js";import"./chunk-DJZXZyJn.js";import"./chunk-A2g_dVj8.js";import"./chunk-30ZbY-F3.js";import"./chunk-BIY1ublO.js";import"./chunk-DeuaeHUI.js";import"./chunk-D53qnCh4.js";import"./chunk-B6KUG25W.js";import"./chunk-DILfnUIk.js";import"./chunk-Bx2M---t.js";import"./chunk-88HG7dU1.js";import"./chunk-DoIo-fWL.js";import"./chunk-CkE6zG_x.js";import"./chunk-Ck98qql-.js";import"./chunk-y0HRaaXz.js";import"./chunk-DV9vF-NS.js";import"./chunk-ByyMTJWo.js";import"./chunk-DkxHCs8B.js";import"./chunk-BOGV63ZI.js";import"./chunk-wPum6LLk.js";import"./chunk-Ccyq873b.js";import"./chunk-DGLf2uCM.js";import"./tripService.ts-CUb9l8sj.js";import"./chunk-Bbmjf7eQ.js";import"./chunk-DV21tWlK.js";import"./chunk-DuSQr7KO.js";import"./chunk-BzRjpoc5.js";import"./chunk-C-NDN0ZE.js";import"./chunk-DtLDND_v.js";import"./chunk-bP8xJp5e.js";import"./chunk-4koW6KZp.js";import"./chunk-ObNbiZMt.js";import"./chunk--XGoeuWx.js";import"./chunk-D393L8yP.js";import"./chunk-DomSceYV.js";import"./chunk-0Vn9svHl.js";import"./chunk-CVnd1dNx.js";import"./chunk-I0kJWO9F.js";import"./chunk-vfQQTDq4.js";import"./chunk-CeA63noh.js";import"./chunk-C5qHPTeJ.js";import"./chunk-vJ6XLRYv.js";import"./chunk-BBFu0Y12.js";import"./chunk-CeVrn2l1.js";function r(t){const e=t.split("/").filter(t=>"."!==t),i=[];return e.forEach(t=>{".."===t&&i.length>0&&".."!==i[i.length-1]?i.pop():i.push(t)}),i.join("/")}class o extends t{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async t=>{var i,r;const o=e(t,t.webFetchExtra),s=await fetch(t.url,o);let n;if(t.progress)if(null==s?void 0:s.body){const e=s.body.getReader();let i=0;const r=[],o=s.headers.get("content-type"),a=parseInt(s.headers.get("content-length")||"0",10);for(;;){const{done:o,value:s}=await e.read();if(o)break;r.push(s),i+=(null==s?void 0:s.length)||0;const n={url:t.url,bytes:i,contentLength:a};this.notifyListeners("progress",n)}const c=new Uint8Array(i);let h=0;for(const t of r)void 0!==t&&(c.set(t,h),h+=t.length);n=new Blob([c.buffer],{type:o||void 0})}else n=new Blob;else n=await s.blob();return{path:(await this.writeFile({path:t.path,directory:null!==(i=t.directory)&&void 0!==i?i:void 0,recursive:null!==(r=t.recursive)&&void 0!==r&&r,data:n})).uri,blob:n}}}readFileInChunks(t,e){throw this.unavailable("Method not implemented.")}async initDb(){if(void 0!==this._db)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise((t,e)=>{const i=indexedDB.open(this.DB_NAME,this.DB_VERSION);i.onupgradeneeded=o.doUpgrade,i.onsuccess=()=>{this._db=i.result,t(i.result)},i.onerror=()=>e(i.error),i.onblocked=()=>{}})}static doUpgrade(t){const e=t.target.result;t.oldVersion;e.objectStoreNames.contains("FileStorage")&&e.deleteObjectStore("FileStorage");e.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}async dbRequest(t,e){const i=-1!==this._writeCmds.indexOf(t)?"readwrite":"readonly";return this.initDb().then(r=>new Promise((o,s)=>{const n=r.transaction(["FileStorage"],i).objectStore("FileStorage")[t](...e);n.onsuccess=()=>o(n.result),n.onerror=()=>s(n.error)}))}async dbIndexRequest(t,e,i){const r=-1!==this._writeCmds.indexOf(e)?"readwrite":"readonly";return this.initDb().then(o=>new Promise((s,n)=>{const a=o.transaction(["FileStorage"],r).objectStore("FileStorage").index(t)[e](...i);a.onsuccess=()=>s(a.result),a.onerror=()=>n(a.error)}))}getPath(t,e){const i=void 0!==e?e.replace(/^[/]+|[/]+$/g,""):"";let r="";return void 0!==t&&(r+="/"+t),""!==e&&(r+="/"+i),r}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(t){const e=this.getPath(t.directory,t.path),i=await this.dbRequest("get",[e]);if(void 0===i)throw Error("File does not exist.");return{data:i.content?i.content:""}}async writeFile(t){const e=this.getPath(t.directory,t.path);let i=t.data;const r=t.encoding,o=t.recursive,s=await this.dbRequest("get",[e]);if(s&&"directory"===s.type)throw Error("The supplied path is a directory.");const n=e.substr(0,e.lastIndexOf("/"));if(void 0===await this.dbRequest("get",[n])){const e=n.indexOf("/",1);if(-1!==e){const i=n.substr(e);await this.mkdir({path:i,directory:t.directory,recursive:o})}}if(!(r||i instanceof Blob||(i=i.indexOf(",")>=0?i.split(",")[1]:i,this.isBase64String(i))))throw Error("The supplied data is not valid base64 content.");const a=Date.now(),c={path:e,folder:n,type:"file",size:i instanceof Blob?i.size:i.length,ctime:a,mtime:a,content:i};return await this.dbRequest("put",[c]),{uri:c.path}}async appendFile(t){const e=this.getPath(t.directory,t.path);let i=t.data;const r=t.encoding,o=e.substr(0,e.lastIndexOf("/")),s=Date.now();let n=s;const a=await this.dbRequest("get",[e]);if(a&&"directory"===a.type)throw Error("The supplied path is a directory.");if(void 0===await this.dbRequest("get",[o])){const e=o.indexOf("/",1);if(-1!==e){const i=o.substr(e);await this.mkdir({path:i,directory:t.directory,recursive:!0})}}if(!r&&!this.isBase64String(i))throw Error("The supplied data is not valid base64 content.");if(void 0!==a){if(a.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");i=void 0===a.content||r?a.content+i:btoa(atob(a.content)+atob(i)),n=a.ctime}const c={path:e,folder:o,type:"file",size:i.length,ctime:n,mtime:s,content:i};await this.dbRequest("put",[c])}async deleteFile(t){const e=this.getPath(t.directory,t.path);if(void 0===await this.dbRequest("get",[e]))throw Error("File does not exist.");if(0!==(await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(e)])).length)throw Error("Folder is not empty.");await this.dbRequest("delete",[e])}async mkdir(t){const e=this.getPath(t.directory,t.path),i=t.recursive,r=e.substr(0,e.lastIndexOf("/")),o=(e.match(/\//g)||[]).length,s=await this.dbRequest("get",[r]),n=await this.dbRequest("get",[e]);if(1===o)throw Error("Cannot create Root directory");if(void 0!==n)throw Error("Current directory does already exist.");if(!i&&2!==o&&void 0===s)throw Error("Parent directory must exist");if(i&&2!==o&&void 0===s){const e=r.substr(r.indexOf("/",1));await this.mkdir({path:e,directory:t.directory,recursive:i})}const a=Date.now(),c={path:e,folder:r,type:"directory",size:0,ctime:a,mtime:a};await this.dbRequest("put",[c])}async rmdir(t){const{path:e,directory:i,recursive:r}=t,o=this.getPath(i,e),s=await this.dbRequest("get",[o]);if(void 0===s)throw Error("Folder does not exist.");if("directory"!==s.type)throw Error("Requested path is not a directory");const n=await this.readdir({path:e,directory:i});if(0!==n.files.length&&!r)throw Error("Folder is not empty");for(const a of n.files){const t=`${e}/${a.name}`;"file"===(await this.stat({path:t,directory:i})).type?await this.deleteFile({path:t,directory:i}):await this.rmdir({path:t,directory:i,recursive:r})}await this.dbRequest("delete",[o])}async readdir(t){const e=this.getPath(t.directory,t.path),i=await this.dbRequest("get",[e]);if(""!==t.path&&void 0===i)throw Error("Folder does not exist.");const r=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(e)]);return{files:await Promise.all(r.map(async t=>{let i=await this.dbRequest("get",[t]);return void 0===i&&(i=await this.dbRequest("get",[t+"/"])),{name:t.substring(e.length+1),type:i.type,size:i.size,ctime:i.ctime,mtime:i.mtime,uri:i.path}}))}}async getUri(t){const e=this.getPath(t.directory,t.path);let i=await this.dbRequest("get",[e]);return void 0===i&&(i=await this.dbRequest("get",[e+"/"])),{uri:(null==i?void 0:i.path)||e}}async stat(t){const e=this.getPath(t.directory,t.path);let i=await this.dbRequest("get",[e]);if(void 0===i&&(i=await this.dbRequest("get",[e+"/"])),void 0===i)throw Error("Entry does not exist.");return{name:i.path.substring(e.length+1),type:i.type,size:i.size,ctime:i.ctime,mtime:i.mtime,uri:i.path}}async rename(t){await this._copy(t,!0)}async copy(t){return this._copy(t,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(t,e=!1){let{toDirectory:o}=t;const{to:s,from:n,directory:a}=t;if(!s||!n)throw Error("Both to and from must be provided");o||(o=a);const c=this.getPath(a,n),h=this.getPath(o,s);if(c===h)return{uri:h};if(function(t,e){t=r(t),e=r(e);const i=t.split("/"),o=e.split("/");return t!==e&&i.every((t,e)=>t===o[e])}(c,h))throw Error("To path cannot contain the from path");let d;try{d=await this.stat({path:s,directory:o})}catch(m){const t=s.split("/");t.pop();const e=t.join("/");if(t.length>0){if("directory"!==(await this.stat({path:e,directory:o})).type)throw new Error("Parent directory of the to path is a file")}}if(d&&"directory"===d.type)throw new Error("Cannot overwrite a directory with a file");const u=await this.stat({path:n,directory:a}),p=async(t,e,i)=>{const r=this.getPath(o,t),s=await this.dbRequest("get",[r]);s.ctime=e,s.mtime=i,await this.dbRequest("put",[s])},l=u.ctime?u.ctime:Date.now();switch(u.type){case"file":{const t=await this.readFile({path:n,directory:a});let r;e&&await this.deleteFile({path:n,directory:a}),t.data instanceof Blob||this.isBase64String(t.data)||(r=i.UTF8);const c=await this.writeFile({path:s,directory:o,data:t.data,encoding:r});return e&&await p(s,l,u.mtime),c}case"directory":{if(d)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:s,directory:o,recursive:!1}),e&&await p(s,l,u.mtime)}catch(m){}const t=(await this.readdir({path:n,directory:a})).files;for(const i of t)await this._copy({from:`${n}/${i.name}`,to:`${s}/${i.name}`,directory:a,toDirectory:o},e);e&&await this.rmdir({path:n,directory:a})}}return{uri:h}}isBase64String(t){try{return btoa(atob(t))==t}catch(e){return!1}}}o._debug=!0;export{o as FilesystemWeb};
