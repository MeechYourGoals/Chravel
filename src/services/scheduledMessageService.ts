import { supabase } from './supabaseClient'; // Assuming you have a supabaseClient export
import type { PostgrestSingleResponse } from '@supabase/supabase-js';

export interface ScheduledMessage {
  id?: string; // UUID, generated by DB
  trip_id: string;
  created_by_user_id: string;
  message_content: string;
  tone?: string;
  scheduled_at_utc: string; // ISO string
  status?: string; // 'pending', 'sent', 'failed', 'cancelled'
  recurrence_type?: 'daily' | 'weekly' | 'custom_days' | null; // Add more as needed
  recurrence_details?: { days?: number[] }; // e.g., for weekly { days: [1, 3, 5] } (Mon, Wed, Fri)
  next_send_at_utc?: string | null; // ISO string
  error_message?: string;
  created_at?: string;
  updated_at?: string;
}

export interface ScheduleMessagePayload {
  trip_id: string;
  message_content: string;
  tone?: string;
  scheduled_at_utc: string; // ISO string for the first send time
  recurrence_type?: 'daily' | 'weekly' | 'custom_days' | null;
  recurrence_details?: { days?: number[] }; // e.g., for weekly [0,1,2,3,4,5,6] where 0 is Sunday
}

const TABLE_NAME = 'scheduled_messages';

export class ScheduledMessageService {
  /**
   * Creates a new scheduled message.
   * The user ID is typically fetched from the current session on the backend or passed securely.
   */
  static async createScheduledMessage(payload: ScheduleMessagePayload, userId: string): Promise<PostgrestSingleResponse<ScheduledMessage>> {
    if (!userId) {
      return { data: null, error: { message: 'User ID is required.', details: '', hint: '', code: '401'}, status: 401, statusText: 'Unauthorized', count: null };
    }

    const messageToInsert: Omit<ScheduledMessage, 'id' | 'status' | 'created_at' | 'updated_at' | 'error_message' | 'next_send_at_utc'> & { created_by_user_id: string, next_send_at_utc?: string } = {
      ...payload,
      created_by_user_id: userId,
      // The initial next_send_at_utc is the same as scheduled_at_utc
      // The backend worker will update this for subsequent recurring sends
      next_send_at_utc: payload.scheduled_at_utc
    };

    return supabase
      .from(TABLE_NAME)
      .insert(messageToInsert)
      .select()
      .single();
  }

  /**
   * Fetches scheduled messages for a trip.
   * Add filters as needed (e.g., by status, user).
   */
  static async getScheduledMessagesForTrip(tripId: string): Promise<PostgrestSingleResponse<ScheduledMessage[]>> {
    return supabase
      .from(TABLE_NAME)
      .select('*')
      .eq('trip_id', tripId)
      .order('scheduled_at_utc', { ascending: true });
  }

  /**
   * Updates an existing scheduled message.
   * Ensure only the creator or an admin can update.
   */
  static async updateScheduledMessage(id: string, updates: Partial<ScheduledMessage>): Promise<PostgrestSingleResponse<ScheduledMessage>> {
    // Prevent updating certain fields directly if needed
    const { created_by_user_id, created_at, trip_id, ...validUpdates } = updates;

    // If scheduled_at_utc is updated for a recurring message, next_send_at_utc should also be updated.
    if (validUpdates.scheduled_at_utc && (validUpdates.recurrence_type || (await this.getScheduledMessageById(id)).data?.recurrence_type)) {
        validUpdates.next_send_at_utc = validUpdates.scheduled_at_utc;
    }


    return supabase
      .from(TABLE_NAME)
      .update(validUpdates)
      .eq('id', id)
      .select()
      .single();
  }

  /**
   * Cancels (or deletes) a scheduled message.
   * Using a 'cancelled' status is often better than hard deleting for audit trails.
   */
  static async cancelScheduledMessage(id: string): Promise<PostgrestSingleResponse<ScheduledMessage>> {
    return supabase
      .from(TABLE_NAME)
      .update({ status: 'cancelled', next_send_at_utc: null }) // Stop it from being picked up by worker
      .eq('id', id)
      .select()
      .single();
  }

  /**
   * Deletes a scheduled message. Use with caution.
   */
  static async deleteScheduledMessage(id: string): Promise<PostgrestSingleResponse<null>> {
    return supabase
      .from(TABLE_NAME)
      .delete()
      .eq('id', id);
  }

  /**
   * Fetches a single scheduled message by its ID.
   */
  static async getScheduledMessageById(id: string): Promise<PostgrestSingleResponse<ScheduledMessage>> {
    return supabase
      .from(TABLE_NAME)
      .select('*')
      .eq('id', id)
      .single();
  }
}

// Example usage (typically in your components or other services):
// async function scheduleNewMessage() {
//   const userId = supabase.auth.getUser()?.id; // Get current user ID
//   if (!userId) { console.error("User not logged in"); return; }
//
//   const payload: ScheduleMessagePayload = {
//     trip_id: 'some-trip-uuid',
//     message_content: 'Remember to pack your chargers!',
//     tone: 'Friendly',
//     scheduled_at_utc: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // Tomorrow
//     recurrence_type: 'daily'
//   };
//   const { data, error } = await ScheduledMessageService.createScheduledMessage(payload, userId);
//   if (error) console.error('Error scheduling message:', error);
//   else console.log('Message scheduled:', data);
// }
