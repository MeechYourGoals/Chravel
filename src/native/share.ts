/**
 * Native Sharing + iOS Share Extension ingress (scaffold)
 *
 * Goals
 * - Outbound: Share recap PDFs (and other blobs) via native share sheet on iOS,
 *   with graceful web fallback (Web Share API → download/open fallback).
 * - Inbound: Define a safe contract for an iOS Share Extension to pass shared
 *   items (URLs, images, PDFs) into the app, where the user can choose a Trip
 *   and we persist the item as:
 *    - URL → `trip_links` (Links tab / URLs sub-tab)
 *    - image/pdf/file → `trip_media_index` (Photos/Files tabs)
 *
 * Note
 * - iOS share extensions require Xcode targets + App Group configuration.
 *   This file intentionally scaffolds the JS/TS side and a typed Capacitor
 *   plugin interface (`ChravelShare`) that the native side should implement.
 */
 
import { Capacitor, registerPlugin } from '@capacitor/core';
import type { PluginListenerHandle } from '@capacitor/core';
import { App } from '@capacitor/app';
import { Directory, Filesystem } from '@capacitor/filesystem';
import { Share } from '@capacitor/share';

import { openOrDownloadBlob } from '@/utils/download';

export type InboundSharedKind = 'url' | 'image' | 'pdf' | 'file';

export interface InboundSharedItemBase {
  /** Stable ID generated by the native share pipeline */
  id: string;
  /** Display name (best-effort) */
  name?: string;
  /** Original UTI / MIME type (best-effort) */
  mimeType?: string;
  /** ISO timestamp for when the share happened (best-effort) */
  createdAt?: string;
  /** Optional human-provided text from the share sheet (best-effort) */
  text?: string;
}

export type InboundSharedItem =
  | (InboundSharedItemBase & {
      kind: 'url';
      url: string;
      title?: string;
    })
  | (InboundSharedItemBase & {
      kind: 'image' | 'pdf' | 'file';
      /**
       * Base64 string WITHOUT data-url prefix (preferred).
       * Native plugin can also provide `dataUrl` instead.
       */
      base64?: string;
      /** Optional data URL (`data:<mime>;base64,...`) */
      dataUrl?: string;
      /**
       * Optional local file URI. Native plugin may expose this if it copies
       * the file into the app sandbox.
       */
      fileUri?: string;
    });

export interface InboundSharePullResult {
  items: InboundSharedItem[];
}

/**
 * Capacitor custom plugin contract that a human dev wires up in iOS.
 * The native implementation typically reads from an App Group container
 * and returns queued share items.
 */
export interface ChravelSharePlugin {
  /**
   * Fetch any queued share items (e.g. written by the Share Extension).
   * Should be idempotent; items are removed only when `consume()` is called.
   */
  getPendingShares(): Promise<InboundSharePullResult>;

  /** Mark one or more items as consumed so they won't re-appear. */
  consume(options: { ids: string[] }): Promise<void>;

  /**
   * Optional event fired when the native app is opened via share flow.
   * (Not required if you prefer polling on resume/appUrlOpen.)
   */
  addListener?(
    eventName: 'shareReceived',
    listenerFunc: (event: InboundSharePullResult) => void,
  ): Promise<PluginListenerHandle> & PluginListenerHandle;
}

const ChravelShare = registerPlugin<ChravelSharePlugin>('ChravelShare');

export function isNativeShareSheetAvailable(): boolean {
  return Capacitor.isNativePlatform() && Capacitor.isPluginAvailable('Share');
}

export function isNativeShareInboxAvailable(): boolean {
  return Capacitor.isNativePlatform() && Capacitor.isPluginAvailable('ChravelShare');
}

export interface ShareResult {
  success: boolean;
  error?: string;
  /**
   * If true, we used a fallback (Web Share API prompt/download).
   * Useful for telemetry/UX tuning.
   */
  usedFallback?: boolean;
}

function stripDataUrlPrefix(base64OrDataUrl: string): { base64: string; mimeType?: string } {
  const trimmed = base64OrDataUrl.trim();
  const match = /^data:([^;]+);base64,(.*)$/i.exec(trimmed);
  if (!match) return { base64: trimmed };
  return { mimeType: match[1], base64: match[2] ?? '' };
}

function base64ToBlob(base64: string, mimeType: string): Blob {
  // atob handles standard base64 (native + modern web). For URL-safe base64,
  // native should normalize before sending.
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return new Blob([bytes], { type: mimeType });
}

async function blobToBase64(blob: Blob): Promise<string> {
  // Convert to data URL then strip prefix (Filesystem expects raw base64).
  const dataUrl = await new Promise<string>((resolve, reject) => {
    const reader = new FileReader();
    reader.onerror = () => reject(new Error('Failed to read blob'));
    reader.onload = () => resolve(String(reader.result));
    reader.readAsDataURL(blob);
  });
  return stripDataUrlPrefix(dataUrl).base64;
}

function defaultFilenameForMime(mimeType: string, fallbackBase: string): string {
  const byMime: Record<string, string> = {
    'application/pdf': 'pdf',
    'image/png': 'png',
    'image/jpeg': 'jpg',
    'image/jpg': 'jpg',
    'image/gif': 'gif',
    'text/plain': 'txt',
    'text/uri-list': 'txt',
  };
  const ext = byMime[mimeType] ?? 'bin';
  return `${fallbackBase}.${ext}`;
}

async function writeBlobToNativeTempFile(params: {
  blob: Blob;
  filename: string;
}): Promise<string> {
  const base64 = await blobToBase64(params.blob);
  const path = `share/${crypto.randomUUID()}-${params.filename}`;

  await Filesystem.writeFile({
    path,
    data: base64,
    directory: Directory.Cache,
    recursive: true,
  });

  const uri = await Filesystem.getUri({ path, directory: Directory.Cache });
  return uri.uri;
}

/**
 * Outbound share of a URL/text (native share sheet on iOS; Web Share fallback).
 */
export async function shareTextOrUrl(options: {
  title?: string;
  text?: string;
  url?: string;
}): Promise<ShareResult> {
  // Native (Capacitor)
  if (isNativeShareSheetAvailable()) {
    try {
      await Share.share({
        title: options.title,
        text: options.text,
        url: options.url,
      });
      return { success: true };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Share failed';
      return { success: false, error: message };
    }
  }

  // Web
  try {
    if (navigator.share) {
      await navigator.share({
        title: options.title,
        text: options.text,
        url: options.url,
      });
      return { success: true, usedFallback: true };
    }
  } catch (error) {
    // AbortError = user cancelled, treat as non-fatal but not "success".
    if (error instanceof Error && error.name === 'AbortError') {
      return { success: false, error: 'Sharing cancelled', usedFallback: true };
    }
  }

  // Last resort: copy via `platform/sharing.ts` exists, but we keep this module
  // dependency-light and simply return failure so the caller can show UI.
  return { success: false, error: 'Sharing not supported on this platform', usedFallback: true };
}

/**
 * Outbound: share a recap PDF (or any blob) with the best UX available.
 *
 * - Native iOS (Capacitor): writes a temp file and invokes share sheet.
 * - Web: uses Web Share API with files where possible, else download/open fallback.
 */
export async function shareBlob(params: {
  blob: Blob;
  filename: string;
  title?: string;
  text?: string;
}): Promise<ShareResult> {
  if (isNativeShareSheetAvailable()) {
    try {
      const uri = await writeBlobToNativeTempFile({ blob: params.blob, filename: params.filename });
      await Share.share({
        title: params.title ?? params.filename,
        text: params.text,
        url: uri,
      });
      return { success: true };
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Share failed';
      return { success: false, error: message };
    }
  }

  // Web fallback (this tries Web Share API with files first)
  try {
    await openOrDownloadBlob(params.blob, params.filename, { mimeType: params.blob.type });
    return { success: true, usedFallback: true };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Share failed';
    return { success: false, error: message, usedFallback: true };
  }
}

/**
 * Convenience specifically for recap PDFs.
 */
export async function shareRecapPdf(params: {
  pdfBlob: Blob;
  filename?: string;
  title?: string;
  text?: string;
}): Promise<ShareResult> {
  const filename = params.filename ?? 'Chravel-Recap.pdf';
  const blob =
    params.pdfBlob.type === 'application/pdf'
      ? params.pdfBlob
      : new Blob([params.pdfBlob], { type: 'application/pdf' });
  return await shareBlob({
    blob,
    filename,
    title: params.title ?? 'Trip recap',
    text: params.text,
  });
}

/**
 * Inbound: Pull any pending share items from the native queue.
 * No-op (empty list) on web.
 */
export async function pullInboundShares(): Promise<InboundSharedItem[]> {
  if (!isNativeShareInboxAvailable()) return [];

  try {
    const { items } = await ChravelShare.getPendingShares();
    return Array.isArray(items) ? items : [];
  } catch (error) {
    // Non-fatal; ingress should never crash startup.
    if (import.meta.env.DEV) {
      console.warn('[Share] Failed to pull inbound shares:', error);
    }
    return [];
  }
}

export async function consumeInboundShares(ids: string[]): Promise<void> {
  if (!isNativeShareInboxAvailable()) return;
  if (!Array.isArray(ids) || ids.length === 0) return;

  try {
    await ChravelShare.consume({ ids });
  } catch (error) {
    if (import.meta.env.DEV) {
      console.warn('[Share] Failed to consume inbound shares:', error);
    }
  }
}

export interface InboundShareListenerOptions {
  /**
   * Called when the app becomes active/opened and share items are present.
   * The UI typically persists them, navigates to “Choose Trip”, then ingests.
   */
  onItems: (items: InboundSharedItem[]) => void | Promise<void>;
}

/**
 * Inbound: Best-effort listener that checks for shares on:
 * - appUrlOpen (common pattern when share extension opens app via URL)
 * - resume (user returns to app)
 *
 * Returns a cleanup function.
 */
export function registerInboundShareListener(options: InboundShareListenerOptions): () => void {
  if (!isNativeShareInboxAvailable()) return () => {};

  let cancelled = false;
  const handles: Array<{ remove: () => Promise<void> }> = [];

  const pump = async (): Promise<void> => {
    if (cancelled) return;
    const items = await pullInboundShares();
    if (cancelled) return;
    if (items.length === 0) return;
    await options.onItems(items);
  };

  // Fire once on setup to catch cold-start cases.
  void pump();

  void App.addListener('appUrlOpen', () => {
    void pump();
  }).then(h => handles.push(h));

  void App.addListener('resume', () => {
    void pump();
  }).then(h => handles.push(h));

  return () => {
    cancelled = true;
    for (const h of handles) {
      void h.remove();
    }
  };
}

function bestEffortLinkTitle(url: string): string {
  try {
    const u = new URL(url);
    const host = u.hostname.replace(/^www\./, '');
    return host.length > 0 ? host : 'Shared link';
  } catch {
    return 'Shared link';
  }
}

function normalizeInboundFile(item: Extract<InboundSharedItem, { kind: 'image' | 'pdf' | 'file' }>): {
  mimeType: string;
  filename: string;
  file: File;
} {
  const mimeType =
    item.mimeType ??
    (item.kind === 'pdf' ? 'application/pdf' : item.kind === 'image' ? 'image/*' : 'application/octet-stream');

  const base =
    item.base64 && item.base64.length > 0
      ? { base64: item.base64, mimeType: item.mimeType }
      : item.dataUrl && item.dataUrl.length > 0
        ? stripDataUrlPrefix(item.dataUrl)
        : null;

  if (!base || base.base64.length === 0) {
    // We intentionally do not fetch `fileUri` here: it can be `file://` which
    // is not fetchable from web context; native plugin should provide base64.
    throw new Error('Inbound file missing base64 payload');
  }

  const finalMime = base.mimeType ?? mimeType ?? 'application/octet-stream';
  const blob = base64ToBlob(base.base64, finalMime);
  const filename =
    item.name && item.name.trim().length > 0 ? item.name.trim() : defaultFilenameForMime(finalMime, 'Shared');

  // File constructor is supported in modern browsers + WKWebView; this is used
  // only to pass into existing upload services.
  const file = new File([blob], filename, { type: finalMime });
  return { mimeType: finalMime, filename, file };
}

export interface IngestInboundSharesParams {
  tripId: string;
  items: InboundSharedItem[];
  /** Demo mode impacts link creation behavior (localStorage vs Supabase). */
  isDemoMode: boolean;
}

/**
 * Inbound → Trip routing:
 * - URL: creates a `trip_links` row (so it shows in URLs tab)
 * - image/pdf/file: uploads to `trip_media_index` as image/document
 *
 * Returns the IDs consumed (caller should pass to `consumeInboundShares`).
 */
export async function ingestInboundSharesToTrip(params: IngestInboundSharesParams): Promise<{
  consumedIds: string[];
  created: {
    links: number;
    media: number;
  };
  errors: Array<{ id: string; error: string }>;
}> {
  const consumedIds: string[] = [];
  const errors: Array<{ id: string; error: string }> = [];
  let links = 0;
  let media = 0;

  // Resolve user once for authenticated uploads.
  const { supabase } = await import('@/integrations/supabase/client');
  const { mediaService } = await import('@/services/mediaService');
  const { createTripLink } = await import('@/services/tripLinksService');

  const { data: auth } = await supabase.auth.getUser();
  const userId = auth.user?.id ?? null;

  for (const item of params.items) {
    try {
      if (item.kind === 'url') {
        const url = item.url;
        const title = item.title?.trim() || bestEffortLinkTitle(url);
        const createdLink = await createTripLink(
          {
            tripId: params.tripId,
            url,
            title,
            description: item.text,
            category: 'other',
            addedBy: userId ?? 'share',
          },
          params.isDemoMode,
        );

        if (createdLink) {
          links += 1;
          consumedIds.push(item.id);
        } else {
          throw new Error('Failed to create link');
        }

        continue;
      }

      // Files: require auth unless demo mode.
      if (!params.isDemoMode && !userId) {
        throw new Error('Not authenticated');
      }

      const normalized = normalizeInboundFile(item);
      // Use canonical media upload path so the item shows up in Media/Files.
      await mediaService.uploadMedia({
        tripId: params.tripId,
        file: normalized.file,
        media_type: normalized.mimeType.startsWith('image/') ? 'image' : 'document',
      });

      media += 1;
      consumedIds.push(item.id);
    } catch (error) {
      errors.push({
        id: item.id,
        error: error instanceof Error ? error.message : 'Ingest failed',
      });
    }
  }

  return { consumedIds, created: { links, media }, errors };
}

