export interface OpenAIReviewResult {
  text: string;
  sentiment: 'positive' | 'negative' | 'neutral';
  score: number;
  platforms: string[];
}

export interface OpenAIAudioResult {
  summary: string;
  audioUrl: string;
  duration: number;
  fileKey?: string;
}

export interface OpenAIOptions {
  tone?: 'friendly' | 'professional' | 'funny' | 'urgent' | 'direct' | 'cheerful';
  maxTokens?: number;
}

export interface ChatMessage {
  role: 'system' | 'user' | 'assistant';
  content: string;
}

export class OpenAIService {
  private static async callOpenAI(payload: any) {
    const { supabase } = await import('../integrations/supabase/client');
    const { data, error } = await supabase.functions.invoke('openai-chat', {
      body: payload
    });

    if (error) {
      throw new Error(`OpenAI API Error: ${error.message}`);
    }

    return data;
  }

  static async analyzeReviews(url: string): Promise<OpenAIReviewResult> {
    try {
      const result = await this.callOpenAI({
        message: `Analyze reviews from this URL: ${url}`,
        analysisType: 'review',
        config: { 
          model: 'gpt-4.1-2025-04-14',
          systemPrompt: 'Analyze the reviews and provide a comprehensive summary with sentiment analysis. Return a JSON response with text summary, overall sentiment (positive/negative/neutral), sentiment score (-1 to 1), and platforms mentioned.'
        }
      });

      // Parse the AI response to extract structured data
      try {
        const parsed = JSON.parse(result.response);
        return {
          text: parsed.text || result.response,
          sentiment: parsed.sentiment || 'neutral',
          score: parsed.score || 0,
          platforms: parsed.platforms || []
        };
      } catch {
        return {
          text: result.response,
          sentiment: 'neutral',
          score: result.sentimentScore || 0,
          platforms: []
        };
      }
    } catch (error) {
      console.error('Review analysis error:', error);
      throw error;
    }
  }

  static async generateAudioSummary(url: string, userId: string, tripId?: string): Promise<OpenAIAudioResult> {
    try {
      const result = await this.callOpenAI({
        message: `Generate an engaging audio summary for content from: ${url}`,
        analysisType: 'audio',
        tripContext: { id: tripId, userId },
        config: { 
          model: 'gpt-4.1-2025-04-14',
          systemPrompt: 'Create an engaging, conversational audio summary script. Focus on key insights and actionable information.'
        }
      });

      return {
        summary: result.response,
        audioUrl: '', // Will be generated by audio service
        duration: 0,
        fileKey: `audio_${Date.now()}`
      };
    } catch (error) {
      console.error('Audio summary error:', error);
      throw error;
    }
  }

  static async queryOpenAI(prompt: string, options: OpenAIOptions = {}, tripContext?: any, chatHistory?: ChatMessage[]): Promise<string> {
    try {
      const result = await this.callOpenAI({
        message: prompt,
        tripContext,
        chatHistory,
        analysisType: 'chat',
        config: {
          model: 'gpt-4.1-2025-04-14',
          temperature: 0.7,
          maxTokens: options.maxTokens || 2048
        }
      });

      return result.response;
    } catch (error) {
      console.error('OpenAI query error:', error);
      throw error;
    }
  }

  static async classifyPriority(text: string): Promise<'urgent' | 'reminder' | 'fyi'> {
    try {
      const result = await this.callOpenAI({
        message: `Classify the priority of this message: "${text}"`,
        analysisType: 'sentiment',
        config: {
          model: 'gpt-4.1-2025-04-14',
          systemPrompt: 'Classify this message priority as exactly one of: urgent, reminder, or fyi. Respond with only the classification.'
        }
      });

      const priority = result.response.toLowerCase().trim();
      
      if (['urgent', 'reminder', 'fyi'].includes(priority)) {
        return priority as 'urgent' | 'reminder' | 'fyi';
      }
      
      return 'fyi';
    } catch (error) {
      console.error('Priority classification error:', error);
      return 'fyi';
    }
  }

  static async analyzeSentiment(text: string): Promise<{ sentiment: 'positive' | 'negative' | 'neutral'; score: number }> {
    try {
      const result = await this.callOpenAI({
        message: text,
        analysisType: 'sentiment',
        config: {
          model: 'gpt-4.1-2025-04-14',
          systemPrompt: 'Analyze sentiment and return a JSON object with "sentiment" (positive/negative/neutral) and "score" (-1 to 1).'
        }
      });

      return {
        sentiment: result.sentimentScore > 0.2 ? 'positive' : result.sentimentScore < -0.2 ? 'negative' : 'neutral',
        score: result.sentimentScore || 0
      };
    } catch (error) {
      console.error('Sentiment analysis error:', error);
      return { sentiment: 'neutral', score: 0 };
    }
  }

  static async analyzeImage(imageBase64: string, prompt: string): Promise<string> {
    try {
      const result = await this.callOpenAI({
        message: prompt,
        imageBase64,
        analysisType: 'image',
        config: {
          model: 'gpt-4.1-2025-04-14'
        }
      });

      return result.response;
    } catch (error) {
      console.error('Image analysis error:', error);
      throw error;
    }
  }
}